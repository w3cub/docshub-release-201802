
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>contrib.data.TextLineDataset - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content=" Inherits From&#58; Dataset ">
  <meta name="keywords" content="tf, contrib, data, textlinedataset, -, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/tensorflow~python/tf/contrib/data/textlinedataset/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/tensorflow~python.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _tensorflow">
				
<h1 itemprop="name" class="devsite-page-title"> tf.contrib.data.TextLineDataset </h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.contrib.data.TextLineDataset"> <meta itemprop="path" content="r1.4"> <meta itemprop="property" content="output_shapes"> <meta itemprop="property" content="output_types"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="apply"> <meta itemprop="property" content="batch"> <meta itemprop="property" content="cache"> <meta itemprop="property" content="concatenate"> <meta itemprop="property" content="dense_to_sparse_batch"> <meta itemprop="property" content="enumerate"> <meta itemprop="property" content="filter"> <meta itemprop="property" content="flat_map"> <meta itemprop="property" content="from_generator"> <meta itemprop="property" content="from_sparse_tensor_slices"> <meta itemprop="property" content="from_tensor_slices"> <meta itemprop="property" content="from_tensors"> <meta itemprop="property" content="group_by_window"> <meta itemprop="property" content="ignore_errors"> <meta itemprop="property" content="interleave"> <meta itemprop="property" content="list_files"> <meta itemprop="property" content="make_dataset_resource"> <meta itemprop="property" content="make_initializable_iterator"> <meta itemprop="property" content="make_one_shot_iterator"> <meta itemprop="property" content="map"> <meta itemprop="property" content="padded_batch"> <meta itemprop="property" content="prefetch"> <meta itemprop="property" content="range"> <meta itemprop="property" content="repeat"> <meta itemprop="property" content="shard"> <meta itemprop="property" content="shuffle"> <meta itemprop="property" content="skip"> <meta itemprop="property" content="take"> <meta itemprop="property" content="unbatch"> <meta itemprop="property" content="zip"> </div> <h2 id="class_textlinedataset">Class <code>TextLineDataset</code>
</h2> <p>Inherits From: <a href="../dataset/"><code>Dataset</code></a></p> <p>Defined in <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/contrib/data/python/ops/readers.py" target="_blank"><code>tensorflow/contrib/data/python/ops/readers.py</code></a>.</p> <p>A <code>Dataset</code> comprising lines from one or more text files.</p> <h2 id="properties">Properties</h2> <h3 id="output_shapes"><code>output_shapes</code></h3> <h3 id="output_types"><code>output_types</code></h3> <h2 id="methods">Methods</h2> <h3 id="__init__"><code>__init__</code></h3> <pre class="prettyprint lang-python" data-language="python">__init__(
    filenames,
    compression_type=None,
    buffer_size=None
)
</pre> <p>Creates a <code>TextLineDataset</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.TextLineDataset</code>.</p> <h4 id="args">Args:</h4> <ul> <li>
<b><code>filenames</code></b>: A <code>tf.string</code> tensor containing one or more filenames.</li> <li>
<b><code>compression_type</code></b>: (Optional.) A <code>tf.string</code> scalar evaluating to one of <code>""</code> (no compression), <code>"ZLIB"</code>, or <code>"GZIP"</code>.</li> <li>
<b><code>buffer_size</code></b>: (Optional.) A <code>tf.int64</code> scalar denoting the number of bytes to buffer. A value of 0 results in the default buffering values chosen based on the compression type.</li> </ul> <h3 id="apply"><code>apply</code></h3> <pre class="prettyprint lang-python" data-language="python">apply(transformation_func)
</pre> <p>Apply a transformation function to this dataset.</p> <p><code>apply</code> enables chaining of custom <code>Dataset</code> transformations, which are represented as functions that take one <code>Dataset</code> argument and return a transformed <code>Dataset</code>.</p> <p>For example:</p> <pre class="prettyprint" data-language="python">dataset = (dataset.map(lambda x: x ** 2)
           .(group_by_window(key_func, reduce_func, window_size))
           .map(lambda x: x ** 3))
</pre> <h4 id="args_1">Args:</h4> <ul> <li>
<b><code>transformation_func</code></b>: A function that takes one <code>Dataset</code> argument and returns a <code>Dataset</code>.</li> </ul> <h4 id="returns">Returns:</h4> <p>The <code>Dataset</code> returned by applying <code>transformation_func</code> to this dataset.</p> <h3 id="batch"><code>batch</code></h3> <pre class="prettyprint lang-python" data-language="python">batch(batch_size)
</pre> <p>Combines consecutive elements of this dataset into batches.</p> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code>batch_size</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of consecutive elements of this dataset to combine in a single batch.</li> </ul> <h4 id="returns_1">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="cache"><code>cache</code></h3> <pre class="prettyprint lang-python" data-language="python">cache(filename='')
</pre> <p>Caches the elements in this dataset.</p> <h4 id="args_3">Args:</h4> <ul> <li>
<b><code>filename</code></b>: A <code>tf.string</code> scalar <code>tf.Tensor</code>, representing the name of a directory on the filesystem to use for caching tensors in this Dataset. If a filename is not provided, the dataset will be cached in memory.</li> </ul> <h4 id="returns_2">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="concatenate"><code>concatenate</code></h3> <pre class="prettyprint lang-python" data-language="python">concatenate(dataset)
</pre> <p>Creates a <code>Dataset</code> by concatenating given dataset with this dataset.</p> <pre class="prettyprint lang-python" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3 }
b = { 4, 5, 6, 7 }

# Input dataset and dataset to be concatenated should have same
# nested structures and output types.
# c = { (8, 9), (10, 11), (12, 13) }
# d = { 14.0, 15.0, 16.0 }
# a.concatenate(c) and a.concatenate(d) would result in error.

a.concatenate(b) == { 1, 2, 3, 4, 5, 6, 7 }
</pre> <h4 id="args_4">Args:</h4> <ul> <li>
<b><code>dataset</code></b>: <code>Dataset</code> to be concatenated.</li> </ul> <h4 id="returns_3">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="dense_to_sparse_batch"><code>dense_to_sparse_batch</code></h3> <pre class="prettyprint lang-python" data-language="python">dense_to_sparse_batch(
    batch_size,
    row_shape
)
</pre> <p>Use: <code>Dataset.apply(tf.contrib.data.dense_to_sparse_batch(...))</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>ds.apply(tf.contrib.data.dense_to_sparse_batch())</code>.</p> <h3 id="enumerate"><code>enumerate</code></h3> <pre class="prettyprint lang-python" data-language="python">enumerate(start=0)
</pre> <p>Deprecated: Use <code>Dataset.apply(tf.contrib.data.enumerate_dataset(..)</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>ds.apply(tf.contrib.data.enumerate_dataset())</code>.</p> <h3 id="filter"><code>filter</code></h3> <pre class="prettyprint lang-python" data-language="python">filter(predicate)
</pre> <p>Filters this dataset according to <code>predicate</code>.</p> <h4 id="args_5">Args:</h4> <ul> <li>
<b><code>predicate</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a scalar <code>tf.bool</code> tensor.</li> </ul> <h4 id="returns_4">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="flat_map"><code>flat_map</code></h3> <pre class="prettyprint lang-python" data-language="python">flat_map(map_func)
</pre> <p>Maps <code>map_func</code> across this dataset and flattens the result.</p> <h4 id="args_6">Args:</h4> <ul> <li>
<b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a <code>Dataset</code>.</li> </ul> <h4 id="returns_5">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="from_generator"><code>from_generator</code></h3> <pre class="prettyprint lang-python" data-language="python">from_generator(
    generator,
    output_types,
    output_shapes=None
)
</pre> <p>Creates a <code>Dataset</code> whose elements are generated by <code>generator</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.from_generator()</code>.</p> <p>The <code>generator</code> argument must be a callable object that returns an object that support the <code>iter()</code> protocol (e.g. a generator function). The elements generated by <code>generator</code> must be compatible with the given <code>output_types</code> and (optional) <code>output_shapes</code> arguments.</p> <p>For example:</p> <pre class="prettyprint lang-python" data-language="python">import itertools

def gen():
  for i in itertools.count(1):
    yield (i, [1] * i)

ds = Dataset.from_generator(
    gen, (tf.int64, tf.int64), (tf.TensorShape([]), tf.TensorShape([None])))
value = ds.make_one_shot_iterator().get_next()

sess.run(value)  # (1, array([1]))
sess.run(value)  # (2, array([1, 1]))
</pre> <h4 id="args_7">Args:</h4> <ul> <li>
<b><code>generator</code></b>: A callable object that takes no arguments and returns an object that supports the <code>iter()</code> protocol.</li> <li>
<b><code>output_types</code></b>: A nested structure of <code>tf.DType</code> objects corresponding to each component of an element yielded by <code>generator</code>.</li> <li>
<b><code>output_shapes</code></b>: (Optional.) A nested structure of <code>tf.TensorShape</code> objects corresponding to each component of an element yielded by <code>generator</code>.</li> </ul> <h4 id="returns_6">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="from_sparse_tensor_slices"><code>from_sparse_tensor_slices</code></h3> <pre class="prettyprint lang-python" data-language="python">from_sparse_tensor_slices(sparse_tensor)
</pre> <p>Splits each rank-N <code>tf.SparseTensor</code> in this dataset row-wise. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.from_sparse_tensor_slices()</code>.</p> <h4 id="args_8">Args:</h4> <ul> <li>
<b><code>sparse_tensor</code></b>: A <code>tf.SparseTensor</code>.</li> </ul> <h4 id="returns_7">Returns:</h4> <p>A <code>Dataset</code> of rank-(N-1) sparse tensors.</p> <h3 id="from_tensor_slices"><code>from_tensor_slices</code></h3> <pre class="prettyprint lang-python" data-language="python">from_tensor_slices(tensors)
</pre> <p>Creates a <code>Dataset</code> whose elements are slices of the given tensors. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.from_tensor_slices()</code>.</p> <h4 id="args_9">Args:</h4> <ul> <li>
<b><code>tensors</code></b>: A nested structure of tensors, each having the same size in the 0th dimension.</li> </ul> <h4 id="returns_8">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="from_tensors"><code>from_tensors</code></h3> <pre class="prettyprint lang-python" data-language="python">from_tensors(tensors)
</pre> <p>Creates a <code>Dataset</code> with a single element, comprising the given tensors. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.from_tensors()</code>.</p> <h4 id="args_10">Args:</h4> <ul> <li>
<b><code>tensors</code></b>: A nested structure of tensors.</li> </ul> <h4 id="returns_9">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="group_by_window"><code>group_by_window</code></h3> <pre class="prettyprint lang-python" data-language="python">group_by_window(
    key_func,
    reduce_func,
    window_size
)
</pre> <p>Deprecated: Use <code>Dataset.apply(tf.contrib.data.group_by_window(...))</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>ds.apply(tf.contrib.data.group_by_window())</code>.</p> <h3 id="ignore_errors"><code>ignore_errors</code></h3> <pre class="prettyprint lang-python" data-language="python">ignore_errors()
</pre> <p>Deprecated: Use <code>Dataset.apply(tf.contrib.data.ignore_errors())</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>ds.apply(tf.contrib.data.ignore_errors())</code>.</p> <h3 id="interleave"><code>interleave</code></h3> <pre class="prettyprint lang-python" data-language="python">interleave(
    map_func,
    cycle_length,
    block_length=1
)
</pre> <p>Maps <code>map_func</code> across this dataset, and interleaves the results.</p> <p>For example, you can use <code>Dataset.interleave()</code> to process many input files concurrently:</p> <pre class="prettyprint lang-python" data-language="python"># Preprocess 4 files concurrently, and interleave blocks of 16 records from
# each file.
filenames = ["/var/data/file1.txt", "/var/data/file2.txt", ...]
dataset = (Dataset.from_tensor_slices(filenames)
           .interleave(lambda x:
               TextLineDataset(x).map(parse_fn, num_parallel_calls=1),
               cycle_length=4, block_length=16))
</pre> <p>The <code>cycle_length</code> and <code>block_length</code> arguments control the order in which elements are produced. <code>cycle_length</code> controls the number of input elements that are processed concurrently. If you set <code>cycle_length</code> to 1, this transformation will handle one input element at a time, and will produce identical results = to <a href="../dataset/#flat_map"><code>tf.contrib.data.Dataset.flat_map</code></a>. In general, this transformation will apply <code>map_func</code> to <code>cycle_length</code> input elements, open iterators on the returned <code>Dataset</code> objects, and cycle through them producing <code>block_length</code> consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</p> <p>For example:</p> <pre class="prettyprint lang-python" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3, 4, 5 }

# NOTE: New lines indicate "block" boundaries.
a.interleave(lambda x: Dataset.from_tensors(x).repeat(6),
             cycle_length=2, block_length=4) == {
    1, 1, 1, 1,
    2, 2, 2, 2,
    1, 1,
    2, 2,
    3, 3, 3, 3,
    4, 4, 4, 4,
    3, 3,
    4, 4,
    5, 5, 5, 5,
    5, 5,
}
</pre> <p>NOTE: The order of elements yielded by this transformation is deterministic, as long as <code>map_func</code> is a pure function. If <code>map_func</code> contains any stateful operations, the order in which that state is accessed is undefined.</p> <h4 id="args_11">Args:</h4> <ul> <li>
<b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a <code>Dataset</code>.</li> <li>
<b><code>cycle_length</code></b>: The number of elements from this dataset that will be processed concurrently.</li> <li>
<b><code>block_length</code></b>: The number of consecutive elements to produce from each input element before cycling to another input element.</li> </ul> <h4 id="returns_10">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="list_files"><code>list_files</code></h3> <pre class="prettyprint lang-python" data-language="python">list_files(file_pattern)
</pre> <p>A dataset of all files matching a pattern. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.list_files()</code>.</p> <p>Example: If we had the following files on our filesystem: - /path/to/dir/a.txt - /path/to/dir/b.py - /path/to/dir/c.py If we pass "/path/to/dir/*.py" as the directory, the dataset would produce: - /path/to/dir/b.py - /path/to/dir/c.py</p> <h4 id="args_12">Args:</h4> <ul> <li>
<b><code>file_pattern</code></b>: A string or scalar string <code>tf.Tensor</code>, representing the filename pattern that will be matched.</li> </ul> <h4 id="returns_11">Returns:</h4> <p>A <code>Dataset</code> of strings corresponding to file names.</p> <h3 id="make_dataset_resource"><code>make_dataset_resource</code></h3> <pre class="prettyprint lang-python" data-language="python">make_dataset_resource()
</pre> <p>DEPRECATED FUNCTION</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>ds._as_variant_tensor()</code>.</p> <h3 id="make_initializable_iterator"><code>make_initializable_iterator</code></h3> <pre class="prettyprint lang-python" data-language="python">make_initializable_iterator(shared_name=None)
</pre> <p>Creates an <code>Iterator</code> for enumerating the elements of this dataset.</p> <blockquote class="note">
<strong>Note:</strong><span> The returned iterator will be in an uninitialized state, and you must run the <code>iterator.initializer</code> operation before using it:</span>
</blockquote> <pre class="prettyprint lang-python" data-language="python">dataset = ...
iterator = dataset.make_initializable_iterator()
# ...
sess.run(iterator.initializer)
</pre> <h4 id="args_13">Args:</h4> <ul> <li>
<b><code>shared_name</code></b>: (Optional.) If non-empty, the returned iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server).</li> </ul> <h4 id="returns_12">Returns:</h4> <p>An <code>Iterator</code> over the elements of this dataset.</p> <h3 id="make_one_shot_iterator"><code>make_one_shot_iterator</code></h3> <pre class="prettyprint lang-python" data-language="python">make_one_shot_iterator()
</pre> <p>Creates an <code>Iterator</code> for enumerating the elements of this dataset.</p> <p><strong>N.B.</strong> The returned iterator will be initialized automatically. A "one-shot" iterator does not currently support re-initialization.</p> <h4 id="returns_13">Returns:</h4> <p>An <code>Iterator</code> over the elements of this dataset.</p> <h3 id="map"><code>map</code></h3> <pre class="prettyprint lang-python" data-language="python">map(
    map_func,
    num_threads=None,
    output_buffer_size=None,
    num_parallel_calls=None
)
</pre> <p>Maps <code>map_func</code> across this datset. (deprecated arguments)</p> <p>SOME ARGUMENTS ARE DEPRECATED. They will be removed in a future version. Instructions for updating: Replace <code>num_threads=T</code> with <code>num_parallel_calls=T</code>. Replace <code>output_buffer_size=N</code> with <code>ds.prefetch(N)</code> on the returned dataset.</p> <h4 id="args_14">Args:</h4> <ul> <li>
<b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to another nested structure of tensors.</li> <li>
<b><code>num_threads</code></b>: (Optional.) Deprecated, use <code>num_parallel_calls</code> instead.</li> <li>
<b><code>output_buffer_size</code></b>: (Optional.) A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the maximum number of processed elements that will be buffered.</li> <li>
<b><code>num_parallel_calls</code></b>: (Optional.) A <code>tf.int32</code> scalar <code>tf.Tensor</code>, representing the number elements to process in parallel. If not specified, elements will be processed sequentially.</li> </ul> <h4 id="returns_14">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="padded_batch"><code>padded_batch</code></h3> <pre class="prettyprint lang-python" data-language="python">padded_batch(
    batch_size,
    padded_shapes,
    padding_values=None
)
</pre> <p>Combines consecutive elements of this dataset into padded batches.</p> <p>Like <code>Dataset.dense_to_sparse_batch()</code>, this method combines multiple consecutive elements of this dataset, which might have different shapes, into a single element. The tensors in the resulting element have an additional outer dimension, and are padded to the respective shape in <code>padded_shapes</code>.</p> <h4 id="args_15">Args:</h4> <ul> <li>
<b><code>batch_size</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of consecutive elements of this dataset to combine in a single batch.</li> <li>
<b><code>padded_shapes</code></b>: A nested structure of <code>tf.TensorShape</code> or <code>tf.int64</code> vector tensor-like objects representing the shape to which the respective component of each input element should be padded prior to batching. Any unknown dimensions (e.g. <code>tf.Dimension(None)</code> in a <code>tf.TensorShape</code> or <code>-1</code> in a tensor-like object) will be padded to the maximum size of that dimension in each batch.</li> <li>
<b><code>padding_values</code></b>: (Optional.) A nested structure of scalar-shaped <code>tf.Tensor</code>, representing the padding values to use for the respective components. Defaults are <code>0</code> for numeric types and the empty string for string types.</li> </ul> <h4 id="returns_15">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="prefetch"><code>prefetch</code></h3> <pre class="prettyprint lang-python" data-language="python">prefetch(buffer_size)
</pre> <p>Creates a <code>Dataset</code> that prefetches elements from this dataset.</p> <h4 id="args_16">Args:</h4> <ul> <li>
<b><code>buffer_size</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the maximum number elements that will be buffered when prefetching.</li> </ul> <h4 id="returns_16">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="range"><code>range</code></h3> <pre class="prettyprint lang-python" data-language="python">range(*args)
</pre> <p>Creates a <code>Dataset</code> of a step-separated range of values. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.range()</code>.</p> <p>For example:</p> <pre class="prettyprint lang-python" data-language="python">Dataset.range(5) == [0, 1, 2, 3, 4]
Dataset.range(2, 5) == [2, 3, 4]
Dataset.range(1, 5, 2) == [1, 3]
Dataset.range(1, 5, -2) == []
Dataset.range(5, 1) == []
Dataset.range(5, 1, -2) == [5, 3]
</pre> <h4 id="args_17">Args:</h4> <ul> <li>
<b><code>*args</code></b>: follow same semantics as python's xrange. len(args) == 1 -&gt; start = 0, stop = args[0], step = 1 len(args) == 2 -&gt; start = args[0], stop = args[1], step = 1 len(args) == 3 -&gt; start = args[0], stop = args[1, stop = args[2]</li> </ul> <h4 id="returns_17">Returns:</h4> <p>A <code>RangeDataset</code>.</p> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: if len(args) == 0.</li> </ul> <h3 id="repeat"><code>repeat</code></h3> <pre class="prettyprint lang-python" data-language="python">repeat(count=None)
</pre> <p>Repeats this dataset <code>count</code> times.</p> <h4 id="args_18">Args:</h4> <ul> <li>
<b><code>count</code></b>: (Optional.) A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of times the elements of this dataset should be repeated. The default behavior (if <code>count</code> is <code>None</code> or <code>-1</code>) is for the elements to be repeated indefinitely.</li> </ul> <h4 id="returns_18">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="shard"><code>shard</code></h3> <pre class="prettyprint lang-python" data-language="python">shard(
    num_shards,
    index
)
</pre> <p>Creates a <code>Dataset</code> that includes only 1/<code>num_shards</code> of this dataset.</p> <p>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</p> <p>When reading a single input file, you can skip elements as follows:</p> <pre class="prettyprint lang-python" data-language="python">d = tf.contrib.data.TFRecordDataset(FLAGS.input_file)
d = d.shard(FLAGS.num_workers, FLAGS.worker_index)
d = d.repeat(FLAGS.num_epochs)
d = d.shuffle(FLAGS.shuffle_buffer_size)
d = d.map(parser_fn, num_parallel_calls=FLAGS.num_map_threads)
</pre> <p>Important caveats:</p> <ul> <li>Be sure to shard before you use any randomizing operator (such as shuffle).</li> <li>Generally it is best if the shard operator is used early in the dataset pipeline. For example, when reading from a set of TFRecord files, shard before converting the dataset to input samples. This avoids reading every file on every worker. The following is an example of an efficient sharding strategy within a complete pipeline:</li> </ul> <pre class="prettyprint lang-python" data-language="python">d = Dataset.list_files(FLAGS.pattern)
d = d.shard(FLAGS.num_workers, FLAGS.worker_index)
d = d.repeat(FLAGS.num_epochs)
d = d.shuffle(FLAGS.shuffle_buffer_size)
d = d.repeat()
d = d.interleave(tf.contrib.data.TFRecordDataset,
                 cycle_length=FLAGS.num_readers, block_length=1)
d = d.map(parser_fn, num_parallel_calls=FLAGS.num_map_threads)
</pre> <h4 id="args_19">Args:</h4> <ul> <li>
<b><code>num_shards</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of shards operating in parallel.</li> <li>
<b><code>index</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the worker index.</li> </ul> <h4 id="returns_19">Returns:</h4> <p>A <code>Dataset</code>.</p> <h4 id="raises_1">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: if <code>num_shards</code> or <code>index</code> are illegal values. Note: error checking is done on a best-effort basis, and aren't guaranteed to be caught upon dataset creation. (e.g. providing in a placeholder tensor bypasses the early checking, and will instead result in an error during a session.run call.)</li> </ul> <h3 id="shuffle"><code>shuffle</code></h3> <pre class="prettyprint lang-python" data-language="python">shuffle(
    buffer_size,
    seed=None
)
</pre> <p>Randomly shuffles the elements of this dataset.</p> <h4 id="args_20">Args:</h4> <ul> <li>
<b><code>buffer_size</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of elements from this dataset from which the new dataset will sample.</li> <li>
<b><code>seed</code></b>: (Optional.) A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the random seed that will be used to create the distribution. See <a href="../../../set_random_seed/"><code>tf.set_random_seed</code></a> for behavior.</li> </ul> <h4 id="returns_20">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="skip"><code>skip</code></h3> <pre class="prettyprint lang-python" data-language="python">skip(count)
</pre> <p>Creates a <code>Dataset</code> that skips <code>count</code> elements from this dataset.</p> <h4 id="args_21">Args:</h4> <ul> <li>
<b><code>count</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of elements of this dataset that should be skipped to form the new dataset. If <code>count</code> is greater than the size of this dataset, the new dataset will contain no elements. If <code>count</code> is -1, skips the entire dataset.</li> </ul> <h4 id="returns_21">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="take"><code>take</code></h3> <pre class="prettyprint lang-python" data-language="python">take(count)
</pre> <p>Creates a <code>Dataset</code> with at most <code>count</code> elements from this dataset.</p> <h4 id="args_22">Args:</h4> <ul> <li>
<b><code>count</code></b>: A <code>tf.int64</code> scalar <code>tf.Tensor</code>, representing the number of elements of this dataset that should be taken to form the new dataset. If <code>count</code> is -1, or if <code>count</code> is greater than the size of this dataset, the new dataset will contain all elements of this dataset.</li> </ul> <h4 id="returns_22">Returns:</h4> <p>A <code>Dataset</code>.</p> <h3 id="unbatch"><code>unbatch</code></h3> <pre class="prettyprint lang-python" data-language="python">unbatch()
</pre> <p>Deprecated: Use <code>Dataset.apply(tf.contrib.data.unbatch()</code>. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>ds.apply(tf.contrib.data.unbatch())</code>.</p> <h3 id="zip"><code>zip</code></h3> <pre class="prettyprint lang-python" data-language="python">zip(datasets)
</pre> <p>Creates a <code>Dataset</code> by zipping together the given datasets. (deprecated)</p> <p>THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code>tf.data.Dataset.zip()</code>.</p> <p>This method has similar semantics to the built-in <code>zip()</code> function in Python, with the main difference being that the <code>datasets</code> argument can be an arbitrary nested structure of <code>Dataset</code> objects. For example:</p> <pre class="prettyprint lang-python" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3 }
b = { 4, 5, 6 }
c = { (7, 8), (9, 10), (11, 12) }
d = { 13, 14 }

# The nested structure of the `datasets` argument determines the
# structure of elements in the resulting dataset.
Dataset.zip((a, b)) == { (1, 4), (2, 5), (3, 6) }
Dataset.zip((b, a)) == { (4, 1), (5, 2), (6, 3) }

# The `datasets` argument may contain an arbitrary number of
# datasets.
Dataset.zip((a, b, c)) == { (1, 4, (7, 8)),
                            (2, 5, (9, 10)),
                            (3, 6, (11, 12)) }

# The number of elements in the resulting dataset is the same as
# the size of the smallest dataset in `datasets`.
Dataset.zip((a, d)) == { (1, 13), (2, 14) }
</pre> <h4 id="args_23">Args:</h4> <ul> <li>
<b><code>datasets</code></b>: A nested structure of datasets.</li> </ul> <h4 id="returns_23">Returns:</h4> <p>A <code>Dataset</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2017 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/data/TextLineDataset" class="_attribution-link" target="_blank">https://www.tensorflow.org/api_docs/python/tf/contrib/data/TextLineDataset</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
