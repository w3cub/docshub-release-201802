
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.traits - D - W3cubDocs</title>
  
  <meta name="description" content=" Templates which extract information about types and symbols at compile time. ">
  <meta name="keywords" content="std, traits, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_traits/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.traits</h1>  <p>Templates which extract information about types and symbols at compile time. </p>
<p> <br><br>  </p>
<table>
 <tr>
<th scope="col">Category</th> <th scope="col">Templates</th>
</tr> <tr>
<td>Symbol Name traits</td> <td> <a href="#fullyQualifiedName"><code>fullyQualifiedName</code></a> <a href="#moduleName"><code>moduleName</code></a> <a href="#packageName"><code>packageName</code></a> </td>
</tr> <tr>
<td>Function traits</td> <td> <a href="#isFunction"><code>isFunction</code></a> <a href="#arity"><code>arity</code></a> <a href="#functionAttributes"><code>functionAttributes</code></a> <a href="#hasFunctionAttributes"><code>hasFunctionAttributes</code></a> <a href="#functionLinkage"><code>functionLinkage</code></a> <a href="#FunctionTypeOf"><code>FunctionTypeOf</code></a> <a href="#isSafe"><code>isSafe</code></a> <a href="#isUnsafe"><code>isUnsafe</code></a> <a href="#isFinal"><code>isFinal</code></a> <a href="#ParameterDefaults"><code>ParameterDefaults</code></a> <a href="#ParameterIdentifierTuple"><code>ParameterIdentifierTuple</code></a> <a href="#ParameterStorageClassTuple"><code>ParameterStorageClassTuple</code></a> <a href="#Parameters"><code>Parameters</code></a> <a href="#ReturnType"><code>ReturnType</code></a> <a href="#SetFunctionAttributes"><code>SetFunctionAttributes</code></a> <a href="#variadicFunctionStyle"><code>variadicFunctionStyle</code></a> </td>
</tr> <tr>
<td>Aggregate Type traits</td> <td> <a href="#BaseClassesTuple"><code>BaseClassesTuple</code></a> <a href="#BaseTypeTuple"><code>BaseTypeTuple</code></a> <a href="#classInstanceAlignment"><code>classInstanceAlignment</code></a> <a href="#EnumMembers"><code>EnumMembers</code></a> <a href="#FieldNameTuple"><code>FieldNameTuple</code></a> <a href="#Fields"><code>Fields</code></a> <a href="#hasAliasing"><code>hasAliasing</code></a> <a href="#hasElaborateAssign"><code>hasElaborateAssign</code></a> <a href="#hasElaborateCopyConstructor"><code>hasElaborateCopyConstructor</code></a> <a href="#hasElaborateDestructor"><code>hasElaborateDestructor</code></a> <a href="#hasIndirections"><code>hasIndirections</code></a> <a href="#hasMember"><code>hasMember</code></a> <a href="#hasStaticMember"><code>hasStaticMember</code></a> <a href="#hasNested"><code>hasNested</code></a> <a href="#hasUnsharedAliasing"><code>hasUnsharedAliasing</code></a> <a href="#InterfacesTuple"><code>InterfacesTuple</code></a> <a href="#isInnerClass"><code>isInnerClass</code></a> <a href="#isNested"><code>isNested</code></a> <a href="#MemberFunctionsTuple"><code>MemberFunctionsTuple</code></a> <a href="#RepresentationTypeTuple"><code>RepresentationTypeTuple</code></a> <a href="#TemplateArgsOf"><code>TemplateArgsOf</code></a> <a href="#TemplateOf"><code>TemplateOf</code></a> <a href="#TransitiveBaseTypeTuple"><code>TransitiveBaseTypeTuple</code></a> </td>
</tr> <tr>
<td>Type Conversion</td> <td> <a href="#CommonType"><code>CommonType</code></a> <a href="#ImplicitConversionTargets"><code>ImplicitConversionTargets</code></a> <a href="#CopyTypeQualifiers"><code>CopyTypeQualifiers</code></a> <a href="#CopyConstness"><code>CopyConstness</code></a> <a href="#isAssignable"><code>isAssignable</code></a> <a href="#isCovariantWith"><code>isCovariantWith</code></a> <a href="#isImplicitlyConvertible"><code>isImplicitlyConvertible</code></a> </td>
</tr> <tr>
<td>SomethingTypeOf</td> <td> <a href="#rvalueOf"><code>rvalueOf</code></a> <a href="#lvalueOf"><code>lvalueOf</code></a> <a href="#InoutOf"><code>InoutOf</code></a> <a href="#ConstOf"><code>ConstOf</code></a> <a href="#SharedOf"><code>SharedOf</code></a> <a href="#SharedInoutOf"><code>SharedInoutOf</code></a> <a href="#SharedConstOf"><code>SharedConstOf</code></a> <a href="#ImmutableOf"><code>ImmutableOf</code></a> <a href="#QualifierOf"><code>QualifierOf</code></a> </td>
</tr> <tr>
<td>Categories of types</td> <td> <a href="#allSameType"><code>allSameType</code></a> <a href="#ifTestable"><code>ifTestable</code></a> <a href="#isType"><code>isType</code></a> <a href="#isAggregateType"><code>isAggregateType</code></a> <a href="#isArray"><code>isArray</code></a> <a href="#isAssociativeArray"><code>isAssociativeArray</code></a> <a href="#isAutodecodableString"><code>isAutodecodableString</code></a> <a href="#isBasicType"><code>isBasicType</code></a> <a href="#isBoolean"><code>isBoolean</code></a> <a href="#isBuiltinType"><code>isBuiltinType</code></a> <a href="#isCopyable"><code>isCopyable</code></a> <a href="#isDynamicArray"><code>isDynamicArray</code></a> <a href="#isEqualityComparable"><code>isEqualityComparable</code></a> <a href="#isFloatingPoint"><code>isFloatingPoint</code></a> <a href="#isIntegral"><code>isIntegral</code></a> <a href="#isNarrowString"><code>isNarrowString</code></a> <a href="#isConvertibleToString"><code>isConvertibleToString</code></a> <a href="#isNumeric"><code>isNumeric</code></a> <a href="#isOrderingComparable"><code>isOrderingComparable</code></a> <a href="#isPointer"><code>isPointer</code></a> <a href="#isScalarType"><code>isScalarType</code></a> <a href="#isSigned"><code>isSigned</code></a> <a href="#isSomeChar"><code>isSomeChar</code></a> <a href="#isSomeString"><code>isSomeString</code></a> <a href="#isStaticArray"><code>isStaticArray</code></a> <a href="#isUnsigned"><code>isUnsigned</code></a> </td>
</tr> <tr>
<td>Type behaviours</td> <td> <a href="#isAbstractClass"><code>isAbstractClass</code></a> <a href="#isAbstractFunction"><code>isAbstractFunction</code></a> <a href="#isCallable"><code>isCallable</code></a> <a href="#isDelegate"><code>isDelegate</code></a> <a href="#isExpressions"><code>isExpressions</code></a> <a href="#isFinalClass"><code>isFinalClass</code></a> <a href="#isFinalFunction"><code>isFinalFunction</code></a> <a href="#isFunctionPointer"><code>isFunctionPointer</code></a> <a href="#isInstanceOf"><code>isInstanceOf</code></a> <a href="#isIterable"><code>isIterable</code></a> <a href="#isMutable"><code>isMutable</code></a> <a href="#isSomeFunction"><code>isSomeFunction</code></a> <a href="#isTypeTuple"><code>isTypeTuple</code></a> </td>
</tr> <tr>
<td>General Types</td> <td> <a href="#ForeachType"><code>ForeachType</code></a> <a href="#KeyType"><code>KeyType</code></a> <a href="#Largest"><code>Largest</code></a> <a href="#mostNegative"><code>mostNegative</code></a> <a href="#OriginalType"><code>OriginalType</code></a> <a href="#PointerTarget"><code>PointerTarget</code></a> <a href="#Signed"><code>Signed</code></a> <a href="#Unqual"><code>Unqual</code></a> <a href="#Unsigned"><code>Unsigned</code></a> <a href="#ValueType"><code>ValueType</code></a> <a href="#Promoted"><code>Promoted</code></a> </td>
</tr> <tr>
<td>Misc</td> <td> <a href="#mangledName"><code>mangledName</code></a> <a href="#Select"><code>Select</code></a> <a href="#select"><code>select</code></a> </td>
</tr> <tr>
<td>User-Defined Attributes</td> <td> <a href="#hasUDA"><code>hasUDA</code></a> <a href="#getUDAs"><code>getUDAs</code></a> <a href="#getSymbolsByUDA"><code>getSymbolsByUDA</code></a> </td>
</tr> </table>   <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com" target="_blank">Walter Bright</a>, Tomasz Stachowiak (<code>isExpressions</code>), <a href="http://erdani.org" target="_blank">Andrei Alexandrescu</a>, Shin Fujishiro, <a href="http://octarineparrot.com" target="_blank">Robert Clipsham</a>, <a href="http://klickverbot.at" target="_blank">David Nadlinger</a>, Kenji Hara, Shoichi Kato </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/traits.d" target="_blank">std/traits.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="InoutOf">template InoutOf(T)</dt> <dd>
<p>Add the inout qualifier to the given type T.</p> </dd> <dt class="d_decl" id="ConstOf">template ConstOf(T)</dt> <dd>
<p>Add the const qualifier to the given type T.</p> </dd> <dt class="d_decl" id="SharedOf">template SharedOf(T)</dt> <dd>
<p>Add the shared qualifier to the given type T.</p> </dd> <dt class="d_decl" id="SharedInoutOf">template SharedInoutOf(T)</dt> <dd>
<p>Add the shared and inout qualifiers to the given type T.</p> </dd> <dt class="d_decl" id="SharedConstOf">template SharedConstOf(T)</dt> <dd>
<p>Add the shared and const qualifiers to the given type T.</p> </dd> <dt class="d_decl" id="ImmutableOf">template ImmutableOf(T)</dt> <dd>
<p>Add the immutable qualifier to the given type T.</p> </dd> <dt class="d_decl" id="QualifierOf">template QualifierOf(T)</dt> <dd>
<p>Get qualifier template from the given type T</p> </dd> <dt class="d_decl" id="packageName">template packageName(alias T)</dt> <dd>
<p>Get the full package name for the given symbol.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits;
static assert(packageName!packageName == "std");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moduleName">template moduleName(alias T)</dt> <dd>
<p>Get the module name (including package) for the given symbol.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits;
static assert(moduleName!moduleName == "std.traits");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fullyQualifiedName">template fullyQualifiedName(T...) if (T.length == 1)</dt> <dd>
<p>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">module myModule;
struct MyStruct {}
static assert(fullyQualifiedName!(const MyStruct[]) == "const(myModule.MyStruct[])");
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(fullyQualifiedName!fullyQualifiedName == "std.traits.fullyQualifiedName");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ReturnType">template ReturnType(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an <code>opCall</code>. Please note that <span class="d_keyword">ref</span> is not part of a type, but the attribute of the function (see template <a href="#functionAttributes"><code>functionAttributes</code></a>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo();
ReturnType!foo x;   // x is declared as int
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Parameters">template Parameters(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an <code>opCall</code>, a pointer to a struct with an <code>opCall</code>, or a class with an <code>opCall</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo(int, long);
void bar(Parameters!foo);      // declares void bar(int, long);
void abc(Parameters!foo[1]);   // declares void abc(long);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterTypeTuple">alias ParameterTypeTuple = Parameters(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Alternate name for <a href="#Parameters"><code>Parameters</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="arity">template arity(alias func) if (isCallable!func &amp;amp<br>&amp;amp<br>variadicFunctionStyle!func == Variadic.no)</dt> <dd>
<p>Returns the number of arguments of function <code>func</code>. <code>arity</code> is undefined for variadic functions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void foo(){}
static assert(arity!foo == 0);
void bar(uint){}
static assert(arity!bar == 1);
void variadicFoo(uint...){}
static assert(!__traits(compiles, arity!variadicFoo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterStorageClass">enum ParameterStorageClass: uint<br>template ParameterStorageClassTuple(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Get tuple, one per function parameter, of the storage classes of the parameters. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>func</td> <td>function symbol or type of function, delegate, or pointer to function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A tuple of <code>ParameterStorageClass</code> bits</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias STC = ParameterStorageClass; // shorten the enum name

void func(ref int ctx, out real result, real param)
{
}
alias pstc = ParameterStorageClassTuple!func;
static assert(pstc.length == 3); // three parameters
static assert(pstc[0] == STC.ref_);
static assert(pstc[1] == STC.out_);
static assert(pstc[2] == STC.none);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="ParameterStorageClass.none">nonescope_out_ref_lazy_return_</dt> <dd>
<p>These flags can be bitwise OR-ed together to represent complex storage class.</p> </dd> </dl> </dd> <dt class="d_decl" id="extractParameterStorageClassFlags">enum ParameterStorageClass extractParameterStorageClassFlags(Attribs...)</dt> <dd>
<p>Convert string tuple Attribs to ParameterStorageClass bits </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Attribs</td> <td>string tuple</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>ParameterStorageClass bits</dd>
</dl> </dd> <dt class="d_decl" id="ParameterIdentifierTuple">template ParameterIdentifierTuple(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Get, as a tuple, the identifiers of the parameters to a function symbol.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo(int num, string name, int);
static assert([ParameterIdentifierTuple!foo] == ["num", "name", ""]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterDefaults">template ParameterDefaults(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, <code>void</code> is returned instead.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo(int num, string name = "hello", int[] = [1,2,3], lazy int x = 0);
static assert(is(ParameterDefaults!foo[0] == void));
static assert(   ParameterDefaults!foo[1] == "hello");
static assert(   ParameterDefaults!foo[2] == [1,2,3]);
static assert(   ParameterDefaults!foo[3] == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterDefaultValueTuple">alias ParameterDefaultValueTuple = ParameterDefaults(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Alternate name for <a href="#ParameterDefaults"><code>ParameterDefaults</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="FunctionAttribute">enum FunctionAttribute: uint<br>template functionAttributes(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Returns the <code>FunctionAttribute</code> mask for function <code>func</code>. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#hasFunctionAttributes"><code>hasFunctionAttributes</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : functionAttributes, FunctionAttribute;

alias FA = FunctionAttribute; // shorten the enum name

real func(real x) pure nothrow @safe
{
    return x;
}
static assert(functionAttributes!func &amp; FA.pure_);
static assert(functionAttributes!func &amp; FA.safe);
static assert(!(functionAttributes!func &amp; FA.trusted)); // not @trusted
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FunctionAttribute.none">nonepure_nothrow_ref_propertytrustedsafenogcsystemconst_immutable_inout_shared_return_scope_</dt> <dd>
<p>These flags can be bitwise OR-ed together to represent a complex attribute.</p> </dd> </dl> </dd> <dt class="d_decl" id="hasFunctionAttributes">template hasFunctionAttributes(args...) if (args.length &amp;gt<br>0 &amp;amp<br>&amp;amp<br>isCallable!(args[0]) &amp;amp<br>&amp;amp<br>allSatisfy!(isSomeString, typeof(args[1..$])))</dt> <dd>
<p>Checks whether a function has the given attributes attached. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>args</td> <td>Function to check, followed by a variadic number of function attributes as strings</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code>, if the function has the list of attributes attached and <code>false</code> otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#functionAttributes"><code>functionAttributes</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real func(real x) pure nothrow @safe;
static assert(hasFunctionAttributes!(func, "@safe", "pure"));
static assert(!hasFunctionAttributes!(func, "@trusted"));

// for templates attributes are automatically inferred
bool myFunc(T)(T b)
{
    return !b;
}
static assert(hasFunctionAttributes!(myFunc!bool, "@safe", "pure", "@nogc", "nothrow"));
static assert(!hasFunctionAttributes!(myFunc!bool, "shared"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSafe">template isSafe(alias func) if (isCallable!func)</dt> <dd>
<p><code>true</code> if <code>func</code> is <code>@safe</code> or <code>@trusted</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">@safe    int add(int a, int b) {return a+b;}
@trusted int sub(int a, int b) {return a-b;}
@system  int mul(int a, int b) {return a*b;}

static assert( isSafe!add);
static assert( isSafe!sub);
static assert(!isSafe!mul);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isUnsafe">enum auto isUnsafe(alias func)</dt> <dd>
<p><code>true</code> if <code>func</code> is <code>@system</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">@safe    int add(int a, int b) {return a+b;}
@trusted int sub(int a, int b) {return a-b;}
@system  int mul(int a, int b) {return a*b;}

static assert(!isUnsafe!add);
static assert(!isUnsafe!sub);
static assert( isUnsafe!mul);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="functionLinkage">template functionLinkage(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Determine the linkage attribute of the function. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>func</td> <td>the function symbol, or the type of a function, delegate, or pointer to function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>one of the strings "D", "C", "Windows", "Pascal", or "Objective-C"</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">extern(D) void Dfunc() {}
extern(C) void Cfunc() {}
static assert(functionLinkage!Dfunc == "D");
static assert(functionLinkage!Cfunc == "C");

string a = functionLinkage!Dfunc;
writeln(a); // "D"

auto fp = &amp;Cfunc;
string b = functionLinkage!fp;
writeln(b); // "C"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Variadic">enum Variadic: int<br>template variadicFunctionStyle(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Determines what kind of variadic parameters function has. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>func</td> <td>function symbol or type of function, delegate, or pointer to function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>enum <code>Variadic</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void func() {}
static assert(variadicFunctionStyle!func == Variadic.no);

extern(C) int printf(in char*, ...);
static assert(variadicFunctionStyle!printf == Variadic.c);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Variadic.no">no</dt> <dd>
<p>Function is not variadic.</p> </dd> <dt class="d_decl" id="Variadic.c">c</dt> <dd>
<p>Function is a C-style variadic function, which uses</p> </dd> <dt class="d_decl" id="Variadic.d">d</dt> <dd>
<p>core.stdc.stdarg Function is a D-style variadic function, which uses </p>
<p>_argptr and _arguments.</p> </dd> <dt class="d_decl" id="Variadic.typesafe">typesafe</dt> <dd>
<p>Function is a <code>typesafe</code> variadic function.</p> </dd> </dl> </dd> <dt class="d_decl" id="FunctionTypeOf">template FunctionTypeOf(func...) if (func.length == 1 &amp;amp<br>&amp;amp<br>isCallable!func)</dt> <dd>
<p>Get the function type from a callable object <code>func</code>. </p>
<p>Using builtin <code>typeof</code> on a property function yields the types of the property value, not of the property function itself. Still, <code>FunctionTypeOf</code> is able to obtain function types of properties. </p> <dl>
<dt>Note</dt>
<dd> Do not confuse function types with function pointer types; function types are usually used for compile-time reflection purposes.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    int value() @property { return 0; }
}
static assert(is( typeof(C.value) == int ));
static assert(is( FunctionTypeOf!(C.value) == function ));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SetFunctionAttributes">template SetFunctionAttributes(T, string linkage, uint attrs) if (isFunctionPointer!T || isDelegate!T)template SetFunctionAttributes(T, string linkage, uint attrs) if (is(T == function))</dt> <dd>
<p>Constructs a new function or delegate type with the same basic signature as the given one, but different attributes (including linkage). </p>
<p>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The base type.</td>
</tr> <tr>
<td>linkage</td> <td>The desired linkage of the result type.</td>
</tr> <tr>
<td>attrs</td> <td>The desired <a href="#FunctionAttribute"><code>FunctionAttribute</code></a>s of the result type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias ExternC(T) = SetFunctionAttributes!(T, "C", functionAttributes!T);

auto assumePure(T)(T t)
    if (isFunctionPointer!T || isDelegate!T)
{
    enum attrs = functionAttributes!T | FunctionAttribute.pure_;
    return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInnerClass">template isInnerClass(T) if (is(T == class))</dt> <dd>
<p>Determines whether <code>T</code> is a class nested inside another class and that <code>T.outer</code> is the implicit reference to the outer class (i.e. <code>outer</code> has not been used as a field or method name) </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>type to test</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>T</code> is a class nested inside another, with the conditions described above; <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    int outer;
}
static assert(!isInnerClass!C);

class Outer1
{
    class Inner1 { }
    class Inner2
    {
        int outer;
    }
}
static assert(isInnerClass!(Outer1.Inner1));
static assert(!isInnerClass!(Outer1.Inner2));

static class Outer2
{
    static class Inner
    {
        int outer;
    }
}
static assert(!isInnerClass!(Outer2.Inner));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNested">template isNested(T) if (is(T == class) || is(T == struct) || is(T == union))</dt> <dd>
<p>Determines whether <code>T</code> has its own context pointer. <code>T</code> must be either <code>class</code>, <code>struct</code>, or <code>union</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S { }
static assert(!isNested!S);

int i;
struct NestedStruct { void f() { ++i; } }
static assert(isNested!NestedStruct);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasNested">template hasNested(T)</dt> <dd>
<p>Determines whether <code>T</code> or any of its representation types have a context pointer.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S { }

int i;
struct NS { void f() { ++i; } }

static assert(!hasNested!(S[2]));
static assert(hasNested!(NS[2]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Fields">template Fields(T)</dt> <dd>
<p>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If <code>T</code> isn't a struct, class, or union returns a tuple with one element <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { int x; float y; }
static assert(is(Fields!S == AliasSeq!(int, float)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FieldTypeTuple">alias FieldTypeTuple = Fields(T)</dt> <dd>
<p>Alternate name for <a href="#Fields"><code>Fields</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="FieldNameTuple">template FieldNameTuple(T)</dt> <dd>
<p>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If <code>T</code> isn't a struct, class, or union returns an expression tuple with an empty string.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { int x; float y; }
static assert(FieldNameTuple!S == AliasSeq!("x", "y"));
static assert(FieldNameTuple!int == AliasSeq!"");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RepresentationTypeTuple">template RepresentationTypeTuple(T)</dt> <dd>
<p>Get the primitive types of the fields of a struct or class, in topological order.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 { int a; float b; }
struct S2 { char[] a; union { S1 b; S1 * c; } }
alias R = RepresentationTypeTuple!S2;
assert(R.length == 4
    &amp;&amp; is(R[0] == char[]) &amp;&amp; is(R[1] == int)
    &amp;&amp; is(R[2] == float) &amp;&amp; is(R[3] == S1*));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasAliasing">template hasAliasing(T...)</dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code>'s representation includes at least one of the following: </p>
<ol>
<li>a raw pointer <code>U*</code> and <code>U</code> is not immutable;</li> <li>an array <code>U[]</code> and <code>U</code> is not immutable;</li> <li>a reference to a class or interface type <code>C</code> and <code>C</code> is not immutable.</li> <li>an associative array that is not immutable.</li> <li>a delegate.</li>
</ol>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 { int a; Object b; }
struct S2 { string a; }
struct S3 { int a; immutable Object b; }
struct S4 { float[3] vals; }
static assert( hasAliasing!S1);
static assert(!hasAliasing!S2);
static assert(!hasAliasing!S3);
static assert(!hasAliasing!S4);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasIndirections">template hasIndirections(T)</dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code>'s representation includes at least one of the following: </p>
<ol>
<li>a raw pointer <code>U*</code>;</li> <li>an array <code>U[]</code>;</li> <li>a reference to a class type <code>C</code>.</li> <li>an associative array.</li> <li>a delegate.</li>
</ol>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( hasIndirections!(int[string]));
static assert( hasIndirections!(void delegate()));
static assert( hasIndirections!(void delegate() immutable));
static assert( hasIndirections!(immutable(void delegate())));
static assert( hasIndirections!(immutable(void delegate() immutable)));

static assert(!hasIndirections!(void function()));
static assert( hasIndirections!(void*[1]));
static assert(!hasIndirections!(byte[1]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasUnsharedAliasing">template hasUnsharedAliasing(T...)</dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code>'s representation includes at least one of the following: </p>
<ol>
<li>a raw pointer <code>U*</code> and <code>U</code> is not immutable or shared;</li> <li>an array <code>U[]</code> and <code>U</code> is not immutable or shared;</li> <li>a reference to a class type <code>C</code> and <code>C</code> is not immutable or shared.</li> <li>an associative array that is not immutable or shared.</li> <li>a delegate that is not shared.</li>
</ol>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 { int a; Object b; }
struct S2 { string a; }
struct S3 { int a; immutable Object b; }
static assert( hasUnsharedAliasing!S1);
static assert(!hasUnsharedAliasing!S2);
static assert(!hasUnsharedAliasing!S3);

struct S4 { int a; shared Object b; }
struct S5 { char[] a; }
struct S6 { shared char[] b; }
struct S7 { float[3] vals; }
static assert(!hasUnsharedAliasing!S4);
static assert( hasUnsharedAliasing!S5);
static assert(!hasUnsharedAliasing!S6);
static assert(!hasUnsharedAliasing!S7);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateCopyConstructor">template hasElaborateCopyConstructor(S)</dt> <dd>
<p>True if <code>S</code> or any type embedded directly in the representation of <code>S</code> defines an elaborate copy constructor. Elaborate copy constructors are introduced by defining <code>this(this)</code> for a <code>struct</code>. </p>
<p>Classes and unions never have elaborate copy constructors.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateCopyConstructor!int);

static struct S1 { }
static struct S2 { this(this) {} }
static struct S3 { S2 field; }
static struct S4 { S3[1] field; }
static struct S5 { S3[] field; }
static struct S6 { S3[0] field; }
static struct S7 { @disable this(); S3 field; }
static assert(!hasElaborateCopyConstructor!S1);
static assert( hasElaborateCopyConstructor!S2);
static assert( hasElaborateCopyConstructor!(immutable S2));
static assert( hasElaborateCopyConstructor!S3);
static assert( hasElaborateCopyConstructor!(S3[1]));
static assert(!hasElaborateCopyConstructor!(S3[0]));
static assert( hasElaborateCopyConstructor!S4);
static assert(!hasElaborateCopyConstructor!S5);
static assert(!hasElaborateCopyConstructor!S6);
static assert( hasElaborateCopyConstructor!S7);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateAssign">template hasElaborateAssign(S)</dt> <dd>
<p>True if <code>S</code> or any type directly embedded in the representation of <code>S</code> defines an elaborate assignment. Elaborate assignments are introduced by defining <code>opAssign(typeof(this))</code> or <code>opAssign(ref typeof(this))</code> for a <code>struct</code> or when there is a compiler-generated <code>opAssign</code>. </p>
<p>A type <code>S</code> gets compiler-generated <code>opAssign</code> in case it has an elaborate copy constructor or elaborate destructor. <br><br> Classes and unions never have elaborate assignments. </p> <dl>
<dt>Note</dt>
<dd> Structs with (possibly nested) postblit operator(s) will have a hidden yet elaborate compiler generated assignment operator (unless explicitly disabled).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateAssign!int);

static struct S  { void opAssign(S) {} }
static assert( hasElaborateAssign!S);
static assert(!hasElaborateAssign!(const(S)));

static struct S1 { void opAssign(ref S1) {} }
static struct S2 { void opAssign(int) {} }
static struct S3 { S s; }
static assert( hasElaborateAssign!S1);
static assert(!hasElaborateAssign!S2);
static assert( hasElaborateAssign!S3);
static assert( hasElaborateAssign!(S3[1]));
static assert(!hasElaborateAssign!(S3[0]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateDestructor">template hasElaborateDestructor(S)</dt> <dd>
<p>True if <code>S</code> or any type directly embedded in the representation of <code>S</code> defines an elaborate destructor. Elaborate destructors are introduced by defining <code>~this()</code> for a <code> struct</code>. </p>
<p>Classes and unions never have elaborate destructors, even though classes may define <code>~this()</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateDestructor!int);

static struct S1 { }
static struct S2 { ~this() {} }
static struct S3 { S2 field; }
static struct S4 { S3[1] field; }
static struct S5 { S3[] field; }
static struct S6 { S3[0] field; }
static struct S7 { @disable this(); S3 field; }
static assert(!hasElaborateDestructor!S1);
static assert( hasElaborateDestructor!S2);
static assert( hasElaborateDestructor!(immutable S2));
static assert( hasElaborateDestructor!S3);
static assert( hasElaborateDestructor!(S3[1]));
static assert(!hasElaborateDestructor!(S3[0]));
static assert( hasElaborateDestructor!S4);
static assert(!hasElaborateDestructor!S5);
static assert(!hasElaborateDestructor!S6);
static assert( hasElaborateDestructor!S7);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasMember">enum auto hasMember(T, string name)</dt> <dd>
<p>Yields <code>true</code> if and only if <code>T</code> is an aggregate that defines a symbol called <code>name</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasMember!(int, "blah"));
struct S1 { int blah; }
struct S2 { int blah(){ return 0; } }
class C1 { int blah; }
class C2 { int blah(){ return 0; } }
static assert(hasMember!(S1, "blah"));
static assert(hasMember!(S2, "blah"));
static assert(hasMember!(C1, "blah"));
static assert(hasMember!(C2, "blah"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasStaticMember">template hasStaticMember(T, string member)</dt> <dd>
<p>Whether the symbol represented by the string, member, exists and is a static member of T. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>Type containing symbol <code>member</code>.</td>
</tr> <tr>
<td>member</td> <td>Name of symbol to test that resides in <code>T</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff <code>member</code> exists and is static.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S
{
    static void sf() {}
    void f() {}

    static int si;
    int i;
}

static assert( hasStaticMember!(S, "sf"));
static assert(!hasStaticMember!(S, "f"));

static assert( hasStaticMember!(S, "si"));
static assert(!hasStaticMember!(S, "i"));

static assert(!hasStaticMember!(S, "hello"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="EnumMembers">template EnumMembers(E) if (is(E == enum))</dt> <dd>
<p>Retrieves the members of an enumerated type <code>enum E</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E</td> <td>An enumerated type. <code>E</code> may have duplicated values.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Static tuple composed of the members of the enumerated type <code>E</code>. The members are arranged in the same order as declared in <code>E</code>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> An enum can have multiple members which have the same value. If you want to use <code>EnumMembers</code> to e.g. generate switch cases at compile-time, you should use the <a href="../std_meta/#NoDuplicates"><code>std.meta.NoDuplicates</code></a> template to avoid generating duplicate switch cases. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Returned values are strictly typed with <code>E</code>. Thus, the following code does not work without the explicit cast: </dd>
</dl>
<pre data-language="d">enum E : int { a, b, c }
int[] abc = cast(int[]) [ EnumMembers!E ];
</pre> Cast is not necessary if the type of the variable is inferred. See the example below.  <dl>
<dt>Example</dt>
<dd> Creating an array of enumerated values: </dd>
</dl>
<pre data-language="d">enum Sqrts : real
{
    one   = 1,
    two   = 1.41421,
    three = 1.73205,
}
auto sqrts = [ EnumMembers!Sqrts ];
assert(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);
</pre>  A generic function <code>rank(v)</code> in the following example uses this template for finding a member <code>e</code> in an enumerated type <code>E</code>. <pre data-language="d">// Returns i if e is the i-th enumerator of E.
size_t rank(E)(E e)
    if (is(E == enum))
{
    foreach (i, member; EnumMembers!E)
    {
        if (e == member)
            return i;
    }
    assert(0, "Not an enum member");
}

enum Mode
{
    read  = 1,
    write = 2,
    map   = 4,
}
assert(rank(Mode.read ) == 0);
assert(rank(Mode.write) == 1);
assert(rank(Mode.map  ) == 2);
</pre>  </dd> <dt class="d_decl" id="BaseTypeTuple">template BaseTypeTuple(A)</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of the base class and base interfaces of this class or interface. <span class="d_param"><code>BaseTypeTuple</code>!Object</span> returns the empty type tuple.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I1 { }
interface I2 { }
interface I12 : I1, I2 { }
static assert(is(BaseTypeTuple!I12 == AliasSeq!(I1, I2)));

interface I3 : I1 { }
interface I123 : I1, I2, I3 { }
static assert(is(BaseTypeTuple!I123 == AliasSeq!(I1, I2, I3)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BaseClassesTuple">template BaseClassesTuple(T) if (is(T == class))</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of <i>all</i> base classes of this class, in decreasing order. Interfaces are not included. <span class="d_param"> <code>BaseClassesTuple</code>!Object</span> yields the empty type tuple.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C1 { }
class C2 : C1 { }
class C3 : C2 { }
static assert(!BaseClassesTuple!Object.length);
static assert(is(BaseClassesTuple!C1 == AliasSeq!(Object)));
static assert(is(BaseClassesTuple!C2 == AliasSeq!(C1, Object)));
static assert(is(BaseClassesTuple!C3 == AliasSeq!(C2, C1, Object)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InterfacesTuple">template InterfacesTuple(T)</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of <i>all</i> interfaces directly or indirectly inherited by this class or interface. Interfaces do not repeat if multiply implemented. <span class="d_param"><code>InterfacesTuple</code>!Object</span> yields the empty type tuple.</p> </dd> <dt class="d_decl" id="TransitiveBaseTypeTuple">template TransitiveBaseTypeTuple(T)</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of <i>all</i> base classes of <span class="d_param"> T</span>, in decreasing order, followed by <span class="d_param">T</span>'s interfaces. <span class="d_param"><code>TransitiveBaseTypeTuple</code>!Object</span> yields the empty type tuple.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface J1 {}
interface J2 {}
class B1 {}
class B2 : B1, J1, J2 {}
class B3 : B2, J1 {}
alias TL = TransitiveBaseTypeTuple!B3;
writeln(TL.length); // 5
assert(is (TL[0] == B2));
assert(is (TL[1] == B1));
assert(is (TL[2] == Object));
assert(is (TL[3] == J1));
assert(is (TL[4] == J2));

writeln(TransitiveBaseTypeTuple!Object.length); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="MemberFunctionsTuple">template MemberFunctionsTuple(C, string name) if (is(C == class) || is(C == interface))</dt> <dd>
<p>Returns a tuple of non-static functions with the name <code>name</code> declared in the class or interface <code>C</code>. Covariant duplicates are shrunk into the most derived one.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I { I foo(); }
class B
{
    real foo(real v) { return v; }
}
class C : B, I
{
    override C foo() { return this; } // covariant overriding of I.foo()
}
alias foos = MemberFunctionsTuple!(C, "foo");
static assert(foos.length == 2);
static assert(__traits(isSame, foos[0], C.foo));
static assert(__traits(isSame, foos[1], B.foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TemplateOf">template TemplateOf(alias T : Base!Args, alias Base, Args...)template TemplateOf(T : Base!Args, alias Base, Args...)</dt> <dd>
<p>Returns an alias to the template that <code>T</code> is an instance of.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Foo(T, U) {}
static assert(__traits(isSame, TemplateOf!(Foo!(int, real)), Foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TemplateArgsOf">template TemplateArgsOf(alias T : Base!Args, alias Base, Args...)template TemplateArgsOf(T : Base!Args, alias Base, Args...)</dt> <dd>
<p>Returns a <code>AliasSeq</code> of the template arguments used to instantiate <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Foo(T, U) {}
static assert(is(TemplateArgsOf!(Foo!(int, real)) == AliasSeq!(int, real)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="classInstanceAlignment">template classInstanceAlignment(T) if (is(T == class))</dt> <dd>
<p>Returns class instance alignment.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class A { byte b; }
class B { long l; }

// As class instance always has a hidden pointer
static assert(classInstanceAlignment!A == (void*).alignof);
static assert(classInstanceAlignment!B == long.alignof);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CommonType">template CommonType(T...)</dt> <dd>
<p>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns <span class="d_param">void</span> if passed an empty list, or if the types have no common type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias X = CommonType!(int, long, short);
assert(is(X == long));
alias Y = CommonType!(int, char[], short);
assert(is(Y == void));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ImplicitConversionTargets">template ImplicitConversionTargets(T)</dt> <dd>
<p>Returns a tuple with all possible target types of an implicit conversion of a value of type <span class="d_param">T</span>. </p>
<p>Important note: <br><br> The possible targets are computed more conservatively than the D 2.005 compiler does, eliminating all dangerous conversions. For example, <span class="d_param"><code>ImplicitConversionTargets</code>!double</span> does not include <span class="d_param">float</span>.</p> </dd> <dt class="d_decl" id="isImplicitlyConvertible">enum bool isImplicitlyConvertible(From, To)</dt> <dd>
<p>Is <code>From</code> implicitly convertible to <code>To</code>?</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isImplicitlyConvertible!(immutable(char), char));
static assert( isImplicitlyConvertible!(const(char), char));
static assert( isImplicitlyConvertible!(char, wchar));
static assert(!isImplicitlyConvertible!(wchar, char));

static assert(!isImplicitlyConvertible!(const(ushort), ubyte));
static assert(!isImplicitlyConvertible!(const(uint), ubyte));
static assert(!isImplicitlyConvertible!(const(ulong), ubyte));

static assert(!isImplicitlyConvertible!(const(char)[], string));
static assert( isImplicitlyConvertible!(string, const(char)[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAssignable">enum auto isAssignable(Lhs, Rhs = Lhs)</dt> <dd>
<p>Returns <code>true</code> iff a value of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code>. </p>
<p><code>isAssignable</code> returns whether both an lvalue and rvalue can be assigned. <br><br> If you omit <code>Rhs</code>, <code>isAssignable</code> will check identity assignable of <code>Lhs</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isAssignable!(long, int));
static assert(!isAssignable!(int, long));
static assert( isAssignable!(const(char)[], string));
static assert(!isAssignable!(string, char[]));

// int is assignable to int
static assert( isAssignable!int);

// immutable int is not assignable to immutable int
static assert(!isAssignable!(immutable int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isCovariantWith">template isCovariantWith(F, G) if (is(F == function) &amp;amp<br>&amp;amp<br>is(G == function))</dt> <dd>
<p>Determines whether the function type <code>F</code> is covariant with <code>G</code>, i.e., functions of the type <code>F</code> can override ones of the type <code>G</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I { I clone(); }
interface J { J clone(); }
class C : I
{
    override C clone()   // covariant overriding of I.clone()
    {
        return new C;
    }
}

// C.clone() can override I.clone(), indeed.
static assert(isCovariantWith!(typeof(C.clone), typeof(I.clone)));

// C.clone() can't override J.clone(); the return type C is not implicitly
// convertible to J.
static assert(!isCovariantWith!(typeof(C.clone), typeof(J.clone)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rvalueOf">@property T rvalueOf(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init)<br>@property ref T lvalueOf(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init)</dt> <dd>
<p>Creates an lvalue or rvalue of type <code>T</code> for <code>typeof(...)</code> and <code>_traits(compiles, ...)</code> purposes. No actual value is returned. </p>
<dl>
<dt>Note</dt>
<dd> Trying to use returned value will result in a "Symbol Undefined" error at link time. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Note that `f` doesn't have to be implemented
// as is isn't called.
int f(int);
bool f(ref int);
static assert(is(typeof(f(rvalueOf!int)) == int));
static assert(is(typeof(f(lvalueOf!int)) == bool));

int i = rvalueOf!int; // error, no actual value is returned
</pre>  </dd> <dt class="d_decl" id="isBoolean">enum bool isBoolean(T)</dt> <dd>
<p>Detect whether <code>T</code> is a built-in boolean type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isBoolean!bool);
enum EB : bool { a = true }
static assert( isBoolean!EB);
static assert(!isBoolean!(SubTypeOf!bool));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIntegral">enum bool isIntegral(T)</dt> <dd>
<p>Detect whether <code>T</code> is a built-in integral type. Types <code>bool</code>, <code>char</code>, <code>wchar</code>, and <code>dchar</code> are not considered integral.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isIntegral!byte &amp;&amp;
    isIntegral!short &amp;&amp;
    isIntegral!int &amp;&amp;
    isIntegral!long &amp;&amp;
    isIntegral!(const(long)) &amp;&amp;
    isIntegral!(immutable(long))
);

static assert(
    !isIntegral!bool &amp;&amp;
    !isIntegral!char &amp;&amp;
    !isIntegral!double
);

// types which act as integral values do not pass
struct S
{
    int val;
    alias val this;
}

static assert(!isIntegral!S);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFloatingPoint">enum bool isFloatingPoint(T)</dt> <dd>
<p>Detect whether <code>T</code> is a built-in floating point type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isFloatingPoint!float &amp;&amp;
    isFloatingPoint!double &amp;&amp;
    isFloatingPoint!real &amp;&amp;
    isFloatingPoint!(const(real)) &amp;&amp;
    isFloatingPoint!(immutable(real))
);

static assert(!isFloatingPoint!int);

// complex and imaginary numbers do not pass
static assert(
    !isFloatingPoint!cfloat &amp;&amp;
    !isFloatingPoint!ifloat
);

// types which act as floating point values do not pass
struct S
{
    float val;
    alias val this;
}

static assert(!isFloatingPoint!S);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNumeric">enum bool isNumeric(T)</dt> <dd>
<p>Detect whether <code>T</code> is a built-in numeric type (integral or floating point).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isNumeric!byte &amp;&amp;
    isNumeric!short &amp;&amp;
    isNumeric!int &amp;&amp;
    isNumeric!long &amp;&amp;
    isNumeric!float &amp;&amp;
    isNumeric!double &amp;&amp;
    isNumeric!real &amp;&amp;
    isNumeric!(const(real)) &amp;&amp;
    isNumeric!(immutable(real))
);

static assert(
    !isNumeric!void &amp;&amp;
    !isNumeric!bool &amp;&amp;
    !isNumeric!char &amp;&amp;
    !isNumeric!wchar &amp;&amp;
    !isNumeric!dchar
);

// types which act as numeric values do not pass
struct S
{
    int val;
    alias val this;
}

static assert(!isIntegral!S);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isScalarType">enum bool isScalarType(T)</dt> <dd>
<p>Detect whether <code>T</code> is a scalar type (a built-in numeric, character or boolean type).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!isScalarType!void);
static assert( isScalarType!(immutable(byte)));
static assert( isScalarType!(immutable(ushort)));
static assert( isScalarType!(immutable(int)));
static assert( isScalarType!(ulong));
static assert( isScalarType!(shared(float)));
static assert( isScalarType!(shared(const bool)));
static assert( isScalarType!(const(char)));
static assert( isScalarType!(wchar));
static assert( isScalarType!(const(dchar)));
static assert( isScalarType!(const(double)));
static assert( isScalarType!(const(real)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isBasicType">enum bool isBasicType(T)</dt> <dd>
<p>Detect whether <code>T</code> is a basic type (scalar type or void).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isBasicType!void);
static assert(isBasicType!(const(void)));
static assert(isBasicType!(shared(void)));
static assert(isBasicType!(immutable(void)));
static assert(isBasicType!(shared const(void)));
static assert(isBasicType!(shared inout(void)));
static assert(isBasicType!(shared inout const(void)));
static assert(isBasicType!(inout(void)));
static assert(isBasicType!(inout const(void)));
static assert(isBasicType!(immutable(int)));
static assert(isBasicType!(shared(float)));
static assert(isBasicType!(shared(const bool)));
static assert(isBasicType!(const(dchar)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isUnsigned">enum bool isUnsigned(T)</dt> <dd>
<p>Detect whether <code>T</code> is a built-in unsigned numeric type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isUnsigned!uint &amp;&amp;
    isUnsigned!ulong
);

static assert(
    !isUnsigned!char &amp;&amp;
    !isUnsigned!int &amp;&amp;
    !isUnsigned!long &amp;&amp;
    !isUnsigned!char &amp;&amp;
    !isUnsigned!wchar &amp;&amp;
    !isUnsigned!dchar
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSigned">enum bool isSigned(T)</dt> <dd>
<p>Detect whether <code>T</code> is a built-in signed numeric type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isSigned!int &amp;&amp;
    isSigned!long
);

static assert(
    !isSigned!uint &amp;&amp;
    !isSigned!ulong
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSomeChar">enum bool isSomeChar(T)</dt> <dd>
<p>Detect whether <code>T</code> is one of the built-in character types. </p>
<p>The built-in char types are any of <code>char</code>, <code>wchar</code> or <code>dchar</code>, with or without qualifiers.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//Char types
static assert( isSomeChar!char);
static assert( isSomeChar!wchar);
static assert( isSomeChar!dchar);
static assert( isSomeChar!(typeof('c')));
static assert( isSomeChar!(immutable char));
static assert( isSomeChar!(const dchar));

//Non char types
static assert(!isSomeChar!int);
static assert(!isSomeChar!byte);
static assert(!isSomeChar!string);
static assert(!isSomeChar!wstring);
static assert(!isSomeChar!dstring);
static assert(!isSomeChar!(char[4]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSomeString">enum bool isSomeString(T)</dt> <dd>
<p>Detect whether <code>T</code> is one of the built-in string types. </p>
<p>The built-in string types are <code>Char[]</code>, where <code>Char</code> is any of <code>char</code>, <code>wchar</code> or <code>dchar</code>, with or without qualifiers. <br><br> Static arrays of characters (like <code>char[80]</code>) are not considered built-in string types.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//String types
static assert( isSomeString!string);
static assert( isSomeString!(wchar[]));
static assert( isSomeString!(dchar[]));
static assert( isSomeString!(typeof("aaa")));
static assert( isSomeString!(const(char)[]));

enum ES : string { a = "aaa", b = "bbb" }
static assert( isSomeString!ES);

//Non string types
static assert(!isSomeString!int);
static assert(!isSomeString!(int[]));
static assert(!isSomeString!(byte[]));
static assert(!isSomeString!(typeof(null)));
static assert(!isSomeString!(char[4]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNarrowString">enum bool isNarrowString(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a narrow string. </p>
<p>All arrays that use char, wchar, and their qualified versions are narrow strings. (Those include string and wstring).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isNarrowString!string);
static assert(isNarrowString!wstring);
static assert(isNarrowString!(char[]));
static assert(isNarrowString!(wchar[]));

static assert(!isNarrowString!dstring);
static assert(!isNarrowString!(dchar[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isOrderingComparable">enum bool isOrderingComparable(T)<br>enum bool isEqualityComparable(T)</dt> <dd>
<p>Detects whether <code>T</code> is a comparable type. Basic types and structs and classes that implement opCmp are ordering comparable.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isOrderingComparable!int);
static assert(isOrderingComparable!string);
static assert(!isOrderingComparable!creal);

static struct Foo {}
static assert(!isOrderingComparable!Foo);

static struct Bar
{
    int a;
    auto opCmp(Bar b1) const { return a - b1.a; }
}

Bar b1 = Bar(5);
Bar b2 = Bar(7);
assert(isOrderingComparable!Bar &amp;&amp; b2 &gt; b1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isConvertibleToString">enum auto isConvertibleToString(T)</dt> <dd>
<p>Detect whether <code>T</code> is a struct, static array, or enum that is implicitly convertible to a string.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct AliasedString
{
    string s;
    alias s this;
}

enum StringEnum { a = "foo" }

assert(!isConvertibleToString!string);
assert(isConvertibleToString!AliasedString);
assert(isConvertibleToString!StringEnum);
assert(isConvertibleToString!(char[25]));
assert(!isConvertibleToString!(char[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAutodecodableString">enum bool isAutodecodableString(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a string that will be autodecoded. </p>
<p>All arrays that use char, wchar, and their qualified versions are narrow strings. (Those include string and wstring). Aggregates that implicitly cast to narrow strings are included. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>type to be tested</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if T represents a string that is subject to autodecoding  See Also: <a href="#isNarrowString"><code>isNarrowString</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Stringish
{
    string s;
    alias s this;
}
assert(isAutodecodableString!wstring);
assert(isAutodecodableString!Stringish);
assert(!isAutodecodableString!dstring);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isStaticArray">enum bool isStaticArray(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a static array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isStaticArray!(int[3]));
static assert( isStaticArray!(const(int)[5]));
static assert( isStaticArray!(const(int)[][5]));

static assert(!isStaticArray!(const(int)[]));
static assert(!isStaticArray!(immutable(int)[]));
static assert(!isStaticArray!(const(int)[4][]));
static assert(!isStaticArray!(int[]));
static assert(!isStaticArray!(int[char]));
static assert(!isStaticArray!(int[1][]));
static assert(!isStaticArray!(int[int]));
static assert(!isStaticArray!int);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isDynamicArray">enum bool isDynamicArray(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a dynamic array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isDynamicArray!(int[]));
static assert( isDynamicArray!(string));
static assert( isDynamicArray!(long[3][]));

static assert(!isDynamicArray!(int[5]));
static assert(!isDynamicArray!(typeof(null)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isArray">enum bool isArray(T)</dt> <dd>
<p>Detect whether type <code>T</code> is an array (static or dynamic; for associative arrays see <a href="#isAssociativeArray"><code>isAssociativeArray</code></a>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isArray!(int[]));
static assert( isArray!(int[5]));
static assert( isArray!(string));

static assert(!isArray!uint);
static assert(!isArray!(uint[uint]));
static assert(!isArray!(typeof(null)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAssociativeArray">enum bool isAssociativeArray(T)</dt> <dd>
<p>Detect whether <code>T</code> is an associative array type</p> </dd> <dt class="d_decl" id="isBuiltinType">enum bool isBuiltinType(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a builtin type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C;
union U;
struct S;
interface I;

static assert( isBuiltinType!void);
static assert( isBuiltinType!string);
static assert( isBuiltinType!(int[]));
static assert( isBuiltinType!(C[string]));
static assert(!isBuiltinType!C);
static assert(!isBuiltinType!U);
static assert(!isBuiltinType!S);
static assert(!isBuiltinType!I);
static assert(!isBuiltinType!(void delegate(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSIMDVector">enum bool isSIMDVector(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a SIMD vector type.</p> </dd> <dt class="d_decl" id="isPointer">enum bool isPointer(T)</dt> <dd>
<p>Detect whether type <code>T</code> is a pointer.</p> </dd> <dt class="d_decl" id="PointerTarget">template PointerTarget(T : T*)</dt> <dd>
<p>Returns the target type of a pointer.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(PointerTarget!(int*) == int));
static assert(is(PointerTarget!(void*) == void));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAggregateType">enum bool isAggregateType(T)</dt> <dd>
<p>Detect whether type <code>T</code> is an aggregate type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C;
union U;
struct S;
interface I;

static assert( isAggregateType!C);
static assert( isAggregateType!U);
static assert( isAggregateType!S);
static assert( isAggregateType!I);
static assert(!isAggregateType!void);
static assert(!isAggregateType!string);
static assert(!isAggregateType!(int[]));
static assert(!isAggregateType!(C[string]));
static assert(!isAggregateType!(void delegate(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIterable">enum bool isIterable(T)</dt> <dd>
<p>Returns <code>true</code> if T can be iterated over using a <code>foreach</code> loop with a single loop variable of automatically inferred type, regardless of how the <code>foreach</code> loop is implemented. This includes ranges, structs/classes that define <code>opApply</code> with a single loop variable, and builtin dynamic, static and associative arrays.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct OpApply
{
    int opApply(scope int delegate(ref uint) dg) { assert(0); }
}

struct Range
{
    @property uint front() { assert(0); }
    void popFront() { assert(0); }
    enum bool empty = false;
}

static assert( isIterable!(uint[]));
static assert( isIterable!OpApply);
static assert( isIterable!(uint[string]));
static assert( isIterable!Range);

static assert(!isIterable!uint);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isMutable">enum bool isMutable(T)</dt> <dd>
<p>Returns <code>true</code> if T is not const or immutable. Note that <code>isMutable</code> is <code>true</code> for string, or immutable(char)[], because the 'head' is mutable.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isMutable!int);
static assert( isMutable!string);
static assert( isMutable!(shared int));
static assert( isMutable!(shared const(int)[]));

static assert(!isMutable!(const int));
static assert(!isMutable!(inout int));
static assert(!isMutable!(shared(const int)));
static assert(!isMutable!(shared(inout int)));
static assert(!isMutable!(immutable string));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInstanceOf">enum bool isInstanceOf(alias S, T)<br>enum auto isInstanceOf(alias S, alias T)</dt> <dd>
<p>Returns <code>true</code> if T is an instance of the template S.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Foo(T...) { }
static struct Bar(T...) { }
static struct Doo(T) { }
static struct ABC(int x) { }
static void fun(T)() { }
template templ(T) { }

static assert(isInstanceOf!(Foo, Foo!int));
static assert(!isInstanceOf!(Foo, Bar!int));
static assert(!isInstanceOf!(Foo, int));
static assert(isInstanceOf!(Doo, Doo!int));
static assert(isInstanceOf!(ABC, ABC!1));
static assert(!isInstanceOf!(Foo, Foo));
static assert(isInstanceOf!(fun, fun!int));
static assert(isInstanceOf!(templ, templ!int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isExpressions">template isExpressions(T...)</dt> <dd>
<p>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="#isTypeTuple"><code>isTypeTuple</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isExpressions!(1, 2.0, "a"));
static assert(!isExpressions!(int, double, string));
static assert(!isExpressions!(int, 2.0, "a"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isExpressionTuple">alias isExpressionTuple = isExpressions(T...)</dt> <dd>
<p>Alternate name for <a href="#isExpressions"><code>isExpressions</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="isTypeTuple">template isTypeTuple(T...)</dt> <dd>
<p>Check whether the tuple <code>T</code> is a type tuple. A type tuple only contains types. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="#isExpressions"><code>isExpressions</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isTypeTuple!(int, float, string));
static assert(!isTypeTuple!(1, 2.0, "a"));
static assert(!isTypeTuple!(1, double, string));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFunctionPointer">template isFunctionPointer(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>T</code> is a function pointer.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void foo() {}
void bar() {}

auto fpfoo = &amp;foo;
static assert( isFunctionPointer!fpfoo);
static assert( isFunctionPointer!(void function()));

auto dgbar = &amp;bar;
static assert(!isFunctionPointer!dgbar);
static assert(!isFunctionPointer!(void delegate()));
static assert(!isFunctionPointer!foo);
static assert(!isFunctionPointer!bar);

static assert( isFunctionPointer!((int a) {}));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isDelegate">template isDelegate(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>T</code> is a delegate.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void sfunc() { }
int x;
void func() { x++; }

int delegate() dg;
assert(isDelegate!dg);
assert(isDelegate!(int delegate()));
assert(isDelegate!(typeof(&amp;func)));

int function() fp;
assert(!isDelegate!fp);
assert(!isDelegate!(int function()));
assert(!isDelegate!(typeof(&amp;sfunc)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSomeFunction">template isSomeFunction(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>T</code> is a function, a function pointer or a delegate.</p> </dd> <dt class="d_decl" id="isCallable">template isCallable(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is a callable object, which can be called with the function call operator <code>(...)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I { real value() @property; }
struct S { static int opCall(int) { return 0; } }
class C { int opCall(int) { return 0; } }
auto c = new C;

static assert( isCallable!c);
static assert( isCallable!S);
static assert( isCallable!(c.opCall));
static assert( isCallable!(I.value));
static assert( isCallable!((int a) { return a; }));

static assert(!isCallable!I);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAbstractFunction">template isAbstractFunction(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is an abstract function.</p> </dd> <dt class="d_decl" id="isFinalFunction">template isFinalFunction(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is a final function.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { void bar() { } }
final class FC { void foo(); }
class C
{
    void bar() { }
    final void foo();
}
static assert(!isFinalFunction!(int));
static assert(!isFinalFunction!(S.bar));
static assert( isFinalFunction!(FC.foo));
static assert(!isFinalFunction!(C.bar));
static assert( isFinalFunction!(C.foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNestedFunction">enum auto isNestedFunction(alias f)</dt> <dd>
<p>Determines whether function <code>f</code> requires a context pointer.</p> </dd> <dt class="d_decl" id="isAbstractClass">template isAbstractClass(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is an abstract class.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { }
class C { }
abstract class AC { }
static assert(!isAbstractClass!S);
static assert(!isAbstractClass!C);
static assert( isAbstractClass!AC);
C c;
static assert(!isAbstractClass!c);
AC ac;
static assert( isAbstractClass!ac);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinalClass">template isFinalClass(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is a final class.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C { }
abstract class AC { }
final class FC1 : C { }
final class FC2 { }
static assert(!isFinalClass!C);
static assert(!isFinalClass!AC);
static assert( isFinalClass!FC1);
static assert( isFinalClass!FC2);
C c;
static assert(!isFinalClass!c);
FC1 fc1;
static assert( isFinalClass!fc1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Unqual">template Unqual(T)</dt> <dd>
<p>Removes all qualifiers, if any, from type <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(Unqual!int == int));
static assert(is(Unqual!(const int) == int));
static assert(is(Unqual!(immutable int) == int));
static assert(is(Unqual!(shared int) == int));
static assert(is(Unqual!(shared(const int)) == int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CopyTypeQualifiers">template CopyTypeQualifiers(FromType, ToType)</dt> <dd>
<p>Copies type qualifiers from <code>FromType</code> to <code>ToType</code>. </p>
<p>Supported type qualifiers: </p>
<ul> <li><code>const</code></li> <li><code>inout</code></li> <li><code>immutable</code></li> <li><code>shared</code></li> </ul> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(CopyTypeQualifiers!(inout const real, int) == inout const int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CopyConstness">template CopyConstness(FromType, ToType)</dt> <dd>
<p>Returns the type of <code>Target</code> with the "constness" of <code>Source</code>. A type's <b>constness</b> refers to whether it is <code>const</code>, <code>immutable</code>, or <code>inout</code>. If <code>source</code> has no constness, the returned type will be the same as <code>Target</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">const(int) i;
CopyConstness!(typeof(i), float) f;
assert( is(typeof(f) == const float));

CopyConstness!(char, uint) u;
assert( is(typeof(u) == uint));

//The 'shared' qualifier will not be copied
assert(!is(CopyConstness!(shared bool, int) == shared int));

//But the constness will be
assert( is(CopyConstness!(shared const real, double) == const double));

//Careful, const(int)[] is a mutable array of const(int)
alias MutT = CopyConstness!(const(int)[], int);
assert(!is(MutT == const(int)));

//Okay, const(int[]) applies to array and contained ints
alias CstT = CopyConstness!(const(int[]), int);
assert( is(CstT == const(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ForeachType">template ForeachType(T)</dt> <dd>
<p>Returns the inferred type of the loop variable when a variable of type T is iterated over using a <code>foreach</code> loop with a single loop variable and automatically inferred return type. Note that this may not be the same as <code>std.range.ElementType!Range</code> in the case of narrow strings, or if T has both opApply and a range interface.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(ForeachType!(uint[]) == uint));
static assert(is(ForeachType!string == immutable(char)));
static assert(is(ForeachType!(string[string]) == string));
static assert(is(ForeachType!(inout(int)[]) == inout(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="OriginalType">template OriginalType(T)</dt> <dd>
<p>Strips off all <code>enum</code>s from type <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum E : real { a }
enum F : E    { a = E.a }
alias G = const(F);
static assert(is(OriginalType!E == real));
static assert(is(OriginalType!F == real));
static assert(is(OriginalType!G == const real));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="KeyType">template KeyType(V : V[K], K)</dt> <dd>
<p>Get the Key type of an Associative Array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits;
alias Hash = int[string];
static assert(is(KeyType!Hash == string));
static assert(is(ValueType!Hash == int));
KeyType!Hash str = "a"; // str is declared as string
ValueType!Hash num = 1; // num is declared as int
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ValueType">template ValueType(V : V[K], K)</dt> <dd>
<p>Get the Value type of an Associative Array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits;
alias Hash = int[string];
static assert(is(KeyType!Hash == string));
static assert(is(ValueType!Hash == int));
KeyType!Hash str = "a"; // str is declared as string
ValueType!Hash num = 1; // num is declared as int
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Unsigned">template Unsigned(T)</dt> <dd>
<p>Returns the corresponding unsigned type for T. T must be a numeric integral type, otherwise a compile-time error occurs.</p> </dd> <dt class="d_decl" id="Largest">template Largest(T...) if (T.length &amp;gt<br>= 1)</dt> <dd>
<p>Returns the largest type, i.e. T such that T.sizeof is the largest. If more than one type is of the same size, the leftmost argument of these in will be returned.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(Largest!(uint, ubyte, ushort, real) == real));
static assert(is(Largest!(ulong, double) == ulong));
static assert(is(Largest!(double, ulong) == double));
static assert(is(Largest!(uint, byte, double, short) == double));
static if (is(ucent))
    static assert(is(Largest!(uint, ubyte, ucent, ushort) == ucent));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Signed">template Signed(T)</dt> <dd>
<p>Returns the corresponding signed type for T. T must be a numeric integral type, otherwise a compile-time error occurs.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias S1 = Signed!uint;
static assert(is(S1 == int));
alias S2 = Signed!(const(uint));
static assert(is(S2 == const(int)));
alias S3 = Signed!(immutable(uint));
static assert(is(S3 == immutable(int)));
static if (is(ucent))
{
    alias S4 = Signed!ucent;
    static assert(is(S4 == cent));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mostNegative">template mostNegative(T) if (isNumeric!T || isSomeChar!T || isBoolean!T)</dt> <dd>
<p>Returns the most negative value of the numeric type T.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(mostNegative!float == -float.max);
static assert(mostNegative!double == -double.max);
static assert(mostNegative!real == -real.max);
static assert(mostNegative!bool == false);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">foreach (T; AliasSeq!(bool, byte, short, int, long))
    static assert(mostNegative!T == T.min);

foreach (T; AliasSeq!(ubyte, ushort, uint, ulong, char, wchar, dchar))
    static assert(mostNegative!T == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Promoted">template Promoted(T) if (isScalarType!T)</dt> <dd>
<p>Get the type that a scalar type <code>T</code> will <a href="https://dlang.org/spec/type.html#integer-promotions" target="_blank">promote</a> to in multi-term arithmetic expressions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte a = 3, b = 5;
static assert(is(typeof(a * b) == Promoted!ubyte));
static assert(is(Promoted!ubyte == int));

static assert(is(Promoted!(shared(bool)) == shared(int)));
static assert(is(Promoted!(const(int)) == const(int)));
static assert(is(Promoted!double == double));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mangledName">template mangledName(sth...) if (sth.length == 1)</dt> <dd>
<p>Returns the mangled name of symbol or type <code>sth</code>. </p>
<p><code>mangledName</code> is the same as builtin <code>.mangleof</code> property, but might be more convenient in generic code, e.g. as a template argument when invoking staticMap.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias TL = staticMap!(mangledName, int, const int, immutable int);
static assert(TL == AliasSeq!("i", "xi", "yi"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Select">template Select(bool condition, T...) if (T.length == 2)</dt> <dd>
<p>Aliases itself to <code>T[0]</code> if the boolean <code>condition</code> is <code>true</code> and to <code>T[1]</code> otherwise.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// can select types
static assert(is(Select!(true, int, long) == int));
static assert(is(Select!(false, int, long) == long));
static struct Foo {}
static assert(is(Select!(false, const(int), const(Foo)) == const(Foo)));

// can select symbols
int a = 1;
int b = 2;
alias selA = Select!(true, a, b);
alias selB = Select!(false, a, b);
writeln(selA); // 1
writeln(selB); // 2

// can select (compile-time) expressions
enum val = Select!(false, -4, 9 - 6);
static assert(val == 3);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="select">A select(bool cond : true, A, B)(A a, lazy B b)<br>B select(bool cond : false, A, B)(lazy A a, B b)</dt> <dd>
<p>If <code>cond</code> is <code>true</code>, returns <code>a</code> without evaluating <code>b</code>. Otherwise, returns <code>b</code> without evaluating <code>a</code>.</p> </dd> <dt class="d_decl" id="hasUDA">enum auto hasUDA(alias symbol, alias attribute)</dt> <dd>
<p>Determine if a symbol has a given <a href="https://dlang.org/spec/attribute.html#uda" target="_blank">user-defined attribute</a>. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#getUDAs"><code>getUDAs</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum E;
struct S {}

@("alpha") int a;
static assert(hasUDA!(a, "alpha"));
static assert(!hasUDA!(a, S));
static assert(!hasUDA!(a, E));

@(E) int b;
static assert(!hasUDA!(b, "alpha"));
static assert(!hasUDA!(b, S));
static assert(hasUDA!(b, E));

@E int c;
static assert(!hasUDA!(c, "alpha"));
static assert(!hasUDA!(c, S));
static assert(hasUDA!(c, E));

@(S, E) int d;
static assert(!hasUDA!(d, "alpha"));
static assert(hasUDA!(d, S));
static assert(hasUDA!(d, E));

@S int e;
static assert(!hasUDA!(e, "alpha"));
static assert(hasUDA!(e, S));
static assert(!hasUDA!(e, S()));
static assert(!hasUDA!(e, E));

@S() int f;
static assert(!hasUDA!(f, "alpha"));
static assert(hasUDA!(f, S));
static assert(hasUDA!(f, S()));
static assert(!hasUDA!(f, E));

@(S, E, "alpha") int g;
static assert(hasUDA!(g, "alpha"));
static assert(hasUDA!(g, S));
static assert(hasUDA!(g, E));

@(100) int h;
static assert(hasUDA!(h, 100));

struct Named { string name; }

@Named("abc") int i;
static assert(hasUDA!(i, Named));
static assert(hasUDA!(i, Named("abc")));
static assert(!hasUDA!(i, Named("def")));

struct AttrT(T)
{
    string name;
    T value;
}

@AttrT!int("answer", 42) int j;
static assert(hasUDA!(j, AttrT));
static assert(hasUDA!(j, AttrT!int));
static assert(!hasUDA!(j, AttrT!string));

@AttrT!string("hello", "world") int k;
static assert(hasUDA!(k, AttrT));
static assert(!hasUDA!(k, AttrT!int));
static assert(hasUDA!(k, AttrT!string));

struct FuncAttr(alias f) { alias func = f; }
static int fourtyTwo() { return 42; }
static size_t getLen(string s) { return s.length; }

@FuncAttr!getLen int l;
static assert(hasUDA!(l, FuncAttr));
static assert(!hasUDA!(l, FuncAttr!fourtyTwo));
static assert(hasUDA!(l, FuncAttr!getLen));
static assert(!hasUDA!(l, FuncAttr!fourtyTwo()));
static assert(!hasUDA!(l, FuncAttr!getLen()));

@FuncAttr!getLen() int m;
static assert(hasUDA!(m, FuncAttr));
static assert(!hasUDA!(m, FuncAttr!fourtyTwo));
static assert(hasUDA!(m, FuncAttr!getLen));
static assert(!hasUDA!(m, FuncAttr!fourtyTwo()));
static assert(hasUDA!(m, FuncAttr!getLen()));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getUDAs">template getUDAs(alias symbol, alias attribute)</dt> <dd>
<p>Gets the matching <a href="https://dlang.org/spec/attribute.html#uda" target="_blank">user-defined attributes</a> from the given symbol. </p>
<p>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match. </p> <dl>
<dt>See Also:</dt>
<dd><a href="#hasUDA"><code>hasUDA</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Attr
{
    string name;
    int value;
}

@Attr("Answer", 42) int a;
static assert(getUDAs!(a, Attr).length == 1);
static assert(getUDAs!(a, Attr)[0].name == "Answer");
static assert(getUDAs!(a, Attr)[0].value == 42);

@(Attr("Answer", 42), "string", 9999) int b;
static assert(getUDAs!(b, Attr).length == 1);
static assert(getUDAs!(b, Attr)[0].name == "Answer");
static assert(getUDAs!(b, Attr)[0].value == 42);

@Attr("Answer", 42) @Attr("Pi", 3) int c;
static assert(getUDAs!(c, Attr).length == 2);
static assert(getUDAs!(c, Attr)[0].name == "Answer");
static assert(getUDAs!(c, Attr)[0].value == 42);
static assert(getUDAs!(c, Attr)[1].name == "Pi");
static assert(getUDAs!(c, Attr)[1].value == 3);

static assert(getUDAs!(c, Attr("Answer", 42)).length == 1);
static assert(getUDAs!(c, Attr("Answer", 42))[0].name == "Answer");
static assert(getUDAs!(c, Attr("Answer", 42))[0].value == 42);

static assert(getUDAs!(c, Attr("Answer", 99)).length == 0);

struct AttrT(T)
{
    string name;
    T value;
}

@AttrT!uint("Answer", 42) @AttrT!int("Pi", 3) @AttrT int d;
static assert(getUDAs!(d, AttrT).length == 2);
static assert(getUDAs!(d, AttrT)[0].name == "Answer");
static assert(getUDAs!(d, AttrT)[0].value == 42);
static assert(getUDAs!(d, AttrT)[1].name == "Pi");
static assert(getUDAs!(d, AttrT)[1].value == 3);

static assert(getUDAs!(d, AttrT!uint).length == 1);
static assert(getUDAs!(d, AttrT!uint)[0].name == "Answer");
static assert(getUDAs!(d, AttrT!uint)[0].value == 42);

static assert(getUDAs!(d, AttrT!int).length == 1);
static assert(getUDAs!(d, AttrT!int)[0].name == "Pi");
static assert(getUDAs!(d, AttrT!int)[0].value == 3);

struct SimpleAttr {}

@SimpleAttr int e;
static assert(getUDAs!(e, SimpleAttr).length == 1);
static assert(is(getUDAs!(e, SimpleAttr)[0] == SimpleAttr));

@SimpleAttr() int f;
static assert(getUDAs!(f, SimpleAttr).length == 1);
static assert(is(typeof(getUDAs!(f, SimpleAttr)[0]) == SimpleAttr));

struct FuncAttr(alias f) { alias func = f; }
static int add42(int v) { return v + 42; }
static string concat(string l, string r) { return l ~ r; }

@FuncAttr!add42 int g;
static assert(getUDAs!(g, FuncAttr).length == 1);
static assert(getUDAs!(g, FuncAttr)[0].func(5) == 47);

static assert(getUDAs!(g, FuncAttr!add42).length == 1);
static assert(getUDAs!(g, FuncAttr!add42)[0].func(5) == 47);

static assert(getUDAs!(g, FuncAttr!add42()).length == 0);

static assert(getUDAs!(g, FuncAttr!concat).length == 0);
static assert(getUDAs!(g, FuncAttr!concat()).length == 0);

@FuncAttr!add42() int h;
static assert(getUDAs!(h, FuncAttr).length == 1);
static assert(getUDAs!(h, FuncAttr)[0].func(5) == 47);

static assert(getUDAs!(h, FuncAttr!add42).length == 1);
static assert(getUDAs!(h, FuncAttr!add42)[0].func(5) == 47);

static assert(getUDAs!(h, FuncAttr!add42()).length == 1);
static assert(getUDAs!(h, FuncAttr!add42())[0].func(5) == 47);

static assert(getUDAs!(h, FuncAttr!concat).length == 0);
static assert(getUDAs!(h, FuncAttr!concat()).length == 0);

@("alpha") @(42) int i;
static assert(getUDAs!(i, "alpha").length == 1);
static assert(getUDAs!(i, "alpha")[0] == "alpha");

static assert(getUDAs!(i, 42).length == 1);
static assert(getUDAs!(i, 42)[0] == 42);

static assert(getUDAs!(i, 'c').length == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getSymbolsByUDA">template getSymbolsByUDA(alias symbol, alias attribute)</dt> <dd>
<p>Gets all symbols within <code>symbol</code> that have the given user-defined attribute. This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum Attr;

static struct A
{
    @Attr int a;
    int b;
    @Attr void doStuff() {}
    void doOtherStuff() {}
    static struct Inner
    {
        // Not found by getSymbolsByUDA
        @Attr int c;
    }
}

// Finds both variables and functions with the attribute, but
// doesn't include the variables and functions without it.
static assert(getSymbolsByUDA!(A, Attr).length == 2);
// Can access attributes on the symbols returned by getSymbolsByUDA.
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[0], Attr));
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[1], Attr));

static struct UDA { string name; }

static struct B
{
    @UDA("X")
    int x;
    @UDA("Y")
    int y;
    @(100)
    int z;
}

// Finds both UDA attributes.
static assert(getSymbolsByUDA!(B, UDA).length == 2);
// Finds one `100` attribute.
static assert(getSymbolsByUDA!(B, 100).length == 1);
// Can get the value of the UDA from the return value
static assert(getUDAs!(getSymbolsByUDA!(B, UDA)[0], UDA)[0].name == "X");

@UDA("A")
static struct C
{
    @UDA("B")
    int d;
}

// Also checks the symbol itself
static assert(getSymbolsByUDA!(C, UDA).length == 2);
static assert(getSymbolsByUDA!(C, UDA)[0].stringof == "C");
static assert(getSymbolsByUDA!(C, UDA)[1].stringof == "d");

static struct D
{
    int x;
}

//Finds nothing if there is no member with specific UDA
static assert(getSymbolsByUDA!(D,UDA).length == 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum Attr;
struct A
{
    alias int INT;
    alias void function(INT) SomeFunction;
    @Attr int a;
    int b;
    @Attr private int c;
    private int d;
}

// Here everything is fine, we have access to private member c
static assert(getSymbolsByUDA!(A, Attr).length == 2);
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[0], Attr));
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[1], Attr));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="allSameType">template allSameType(T...)</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff all types <code>T</code> are the same.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(allSameType!(int, int));
static assert(allSameType!(int, int, int));
static assert(allSameType!(float, float, float));
static assert(!allSameType!(int, double));
static assert(!allSameType!(int, float, double));
static assert(!allSameType!(int, float, double, real));
static assert(!allSameType!(short, int, float, double, real));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ifTestable">enum auto ifTestable(T, alias pred = (a) =&amp;gt<br>a)</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff the type <code>T</code> can be tested in an <code> if</code>-expression, that is if <code>if (pred(T.init)) {}</code> is compilable.</dd>
</dl> </dd> <dt class="d_decl" id="isType">template isType(X...) if (X.length == 1)</dt> <dd>
<p>Detect whether <code>X</code> is a type. Analogous to <code>is(X)</code>. This is useful when used in conjunction with other templates, e.g. <code>allSatisfy!(isType, X)</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>X</code> is a type, <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S {
    template Test() {}
}
class C {}
interface I {}
union U {}
static assert(isType!int);
static assert(isType!string);
static assert(isType!(int[int]));
static assert(isType!S);
static assert(isType!C);
static assert(isType!I);
static assert(isType!U);

int n;
void func(){}
static assert(!isType!n);
static assert(!isType!func);
static assert(!isType!(S.Test));
static assert(!isType!(S.Test!()));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFunction">template isFunction(X...) if (X.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>X</code> is a function. This is different that finding if a symbol is callable or satisfying <code>is(X == function)</code>, it finds specifically if the symbol represents a normal function declaration, i.e. not a delegate or a function pointer. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>X</code> is a function, <code>false</code> otherwise </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Use <a href="#isFunctionPointer"><code>isFunctionPointer</code></a> or <a href="#isDelegate"><code>isDelegate</code></a> for detecting those types respectively.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void func(){}
static assert(isFunction!func);

struct S
{
    void func(){}
}
static assert(isFunction!(S.func));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinal">template isFinal(X...) if (X.length == 1)</dt> <dd>
<p>Detect whether <code>X</code> is a final method or class. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>X</code> is final, <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    void nf() {}
    static void sf() {}
    final void ff() {}
}
final class FC { }

static assert(!isFinal!(C));
static assert( isFinal!(FC));

static assert(!isFinal!(C.nf));
static assert(!isFinal!(C.sf));
static assert( isFinal!(C.ff));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isCopyable">enum auto isCopyable(S)</dt> <dd>
<p>Determines whether the type <code>S</code> can be copied. If a type cannot be copied, then code such as <code>MyStruct x; auto y = x;</code> will fail to compile. Copying for structs can be disabled by using <code>@disable this(this)</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>The type to check.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>S</code> can be copied. <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 {}                        // Fine. Can be copied
struct S2 {         this(this) {}}  // Fine. Can be copied
struct S3 {@disable this(this) {}}  // Not fine. Copying is disabled.
struct S4 {S3 s;}                   // Not fine. A field has copying disabled.

class C1 {}

static assert( isCopyable!S1);
static assert( isCopyable!S2);
static assert(!isCopyable!S3);
static assert(!isCopyable!S4);

static assert(isCopyable!C1);
static assert(isCopyable!int);
static assert(isCopyable!(int[]));
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
     19992017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_traits.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_traits.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
